

















t_cone	*co;
double		a;
double		b;
double		c;
t_vector	tmp;
double		delta;
double		t[3];
â€‹
r.pan = norm_vect(r.pan);
co = s->data;
tmp = sub_vect(r.pos, s->pos);
a = dot_vect(r.pan, r.pan) - ((1 + co->r * co->r)
		* dot_vect(r.pan, co->dir) * dot_vect(r.pan, co->dir));
	b = 2 * (dot_vect(r.pan, tmp)
			- ((1 + co->r * co->r) * dot_vect(r.pan, co->dir)
				* dot_vect(tmp, co->dir)));
	c = dot_vect(tmp, tmp) - ((1 + co->r * co->r)
			* dot_vect(tmp, co->dir)
			* dot_vect(tmp, co->dir));
	delta = b * b - 4 * a * c;
if (delta < 0)
	return (1);
else if (delta == 0)
	t[2] = (-b + sqrtf(delta)) / (2 * a);
	else
{
	t[0] = (-b + sqrtf(delta)) / (2 * a);
	t[1] = (-b - sqrtf(delta)) / (2 * a);
	t[2] = (t[0] < t[1] ? t[0] : t[1]);
	t[2] = (t[2] < 0 ? t[1] : t[2]);
}
if (t[2] < 0)
	return (1);
	s->i = vect(r.pos.x + r.pan.x * t[2], r.pos.y + r.pan.y * t[2], 0);
	s->i.z = r.pos.z + r.pan.z * t[2];
	return (0);




	double		k;
	t_equation	param;

	k = pow(cone->rad / cone->h, 2);
	param.a = pow(ray->d->x, 2) + pow(ray->d->z, 2) - pow(ray->d->y, 2) * k;
	param.b = 2 * (ray->d->x * (ray->o->x - cone->o->x) + ray->d->z *
			(ray->o->z - cone->o->z) - ray->d->y * (ray->o->y - cone->o->y) * k);
param.c = pow((ray->o->x - cone->o->x), 2) + pow((ray->o->z - cone->o->z), 2)
	- pow((ray->o->y - cone->o->y), 2) * k;
	param.discr = param.b * param.b - 4 * param.a * param.c;
if (param.discr < E)
	return (0);
	param.t0 = (-param.b + sqrtf(param.discr)) / (2 * param.a);
	param.t1 = (-param.b - sqrtf(param.discr)) / (2 * param.a);
if (fabs(param.t0) > fabs(param.t1))
	param.t0 = param.t1;
if (param.t0 < 0)
	return (0);
else if (param.t0 < *min)
	*min = param.t0;
	return (param.t0);

double		intersection_cyl(t_object *cyl, t_ray *ray, double *min)
{
	t_equation	param;
	double		k;

	k = pow(cyl->d->x, 2) + pow(cyl->d->y, 2) + pow(cyl->d->z, 2);
	param.a = vectordot(ray->d, ray->d) - (pow(cyl->d->x * ray->d->x
				+ cyl->d->y * ray->d->y + cyl->d->z * ray->d->z, 2) / k);
	param.b = calcule(ray, cyl, k);
	param.c = (ray->o->x - cyl->o->x) * (ray->o->x - cyl->o->x) +
		(ray->o->y - cyl->o->y) * (ray->o->y - cyl->o->y) + (ray->o->z - cyl->o->z)
		* (ray->o->z - cyl->o->z) - (cyl->rad * cyl->rad) - (pow(cyl->d->x *
					(ray->o->x - cyl->o->x) + cyl->d->y * (ray->o->y - cyl->o->y) + cyl->d->z
					* (ray->o->z - cyl->o->z), 2) / k);
	param.discr = param.b * param.b - 4 * param.a * param.c;
	if (param.discr < E)
		return (0);
	param.t0 = (-param.b + sqrtf(param.discr)) / (2 * param.a);
	param.t1 = (-param.b - sqrtf(param.discr)) / (2 * param.a);
	if (fabs(param.t0) > fabs(param.t1))
		param.t0 = param.t1;
	if (param.t0 < 0)
		return (0);
	else if (param.t0 < *min)
		*min = param.t0;
	return (param.t0);
}
Status API Training Shop Blog About

